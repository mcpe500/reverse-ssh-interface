Below is a stack that is **fast**, **portable**, and **maintainable** for a “reverse SSH interface” with **core logic shared** across **CLI + GUI + Web**, while **requiring an existing SSH client** on the target device (your stated requirement).

---

## Recommended tech stack (best fit for your constraints)

### Core (shared logic)

**Language:** **Rust**
**Why:** single static-ish binary possible, excellent performance, strong safety guarantees, good cross-compilation story, and easy to expose the same core to multiple frontends.

**Key crates (core):**

* **Async/runtime:** `tokio`
* **Process orchestration (calling system ssh):** `tokio::process` (or `duct` for ergonomic process piping)
* **Config/serialization:** `serde` + `toml` (or `yaml`)
* **Validation:** `validator` (optional)
* **Logging/telemetry:** `tracing` + `tracing-subscriber`
* **Error handling:** `thiserror`, `anyhow`
* **Secure storage hooks:**

  * Desktop: OS keychain via `keyring` (store *references*, not private keys)
  * In practice: prefer `ssh-agent` and do not store passphrases yourself.

**What “core” actually does (important):**

* Detect/locate `ssh` (`ssh.exe` on Windows) and verify it works.
* Build **argument arrays** (not shell strings) for:

  * reverse tunnels (`-R ...`)
  * keepalives (`ServerAliveInterval`, `ServerAliveCountMax`)
  * safety (`ExitOnForwardFailure`, `IdentitiesOnly`, `StrictHostKeyChecking`)
* Spawn/monitor/restart sessions (a lightweight “autossh-like” supervisor, but inside your app).
* Own all state: sessions, profiles, status, logs, events.

This keeps the “logic mainly in core” exactly as you want.

---

## Frontends (three interfaces)

### CLI

**Rust CLI:** `clap` (+ `clap_complete` if you want shell completions)
Optional (if you want a “rich” terminal UI): `ratatui` (TUI dashboard)

**Why:** same toolchain, smallest surface area, fastest to ship everywhere (Termux included).

---

### Web UI (local web interface)

**Backend:** `axum` (Rust) + `tokio`
**Realtime:** WebSockets (`axum::extract::ws`)
**Frontend:** `SvelteKit` or `React + Vite` (either is fine)

**Pattern that works everywhere:**

* Your app runs a **local server on 127.0.0.1:PORT**
* User opens a browser on the device
* The UI talks to core via WebSocket/HTTP
* Package the built frontend as embedded static assets (so no separate node install at runtime)

This gives you a **web interface** without requiring a “web deployment,” and it works on Windows/macOS/Linux and Termux (phone browser).

---

### GUI (desktop)

**GUI:** **Tauri** (Rust backend + WebView frontend)
Use the **same frontend** you made for the web UI, reused inside Tauri.

**Why:** smallest footprint vs Electron, still fast, easy to call into the Rust core, and packaging is standard.

---

## “Must use installed ssh” (your requirement) — how to do it securely

### Use system OpenSSH as the execution engine

Your core should execute `ssh` as a subprocess and manage it.

**Security must-haves:**

* **Never** build a shell string like `"ssh " + userInput`; always pass args as an array.
* Force safe options by default:

  * `-o ExitOnForwardFailure=yes`
  * `-o ServerAliveInterval=20`
  * `-o ServerAliveCountMax=3`
  * `-o StrictHostKeyChecking=accept-new` (or `yes` if you want stricter behavior)
  * `-o UserKnownHostsFile=...` (app-managed known_hosts is often cleaner)
  * `-o IdentitiesOnly=yes`
* Prefer **key auth + ssh-agent**:

  * Linux/macOS/Termux: `ssh-agent`
  * Windows: OpenSSH agent service (or user-provided agent setup)

**Do not store private keys** inside your app unless you absolutely must. If you need to reference keys, store only paths and metadata; rely on agent / OS keychain for secrets.

---

## Cross-platform targets (what you asked for)

### Linux + macOS

* Rust binary + Tauri app package
* Uses `/usr/bin/ssh` (or PATH)

### Windows

* Use `ssh.exe` (Windows 10/11 OpenSSH Client feature or Git-for-Windows OpenSSH)
* Your core should:

  * check `ssh.exe` is present
  * allow user to set a custom path if not
  * warn when host key policies differ

### Android (Termux)

* The **CLI** is the primary deliverable
* Termux already has OpenSSH available (`pkg install openssh`)
* Your Rust binary compiled for `aarch64-linux-android` works well here

If you later want a “real” Android app UI, you can wrap the same core via FFI, but you do not need that to satisfy “works on mobile ARM that supports ssh.”

---

## Packaging / release executables

### CLI release

* Ship a **single binary** per platform/arch.
* Use CI (GitHub Actions) to build:

  * `x86_64-unknown-linux-gnu` (and optionally musl)
  * `aarch64-unknown-linux-gnu`
  * `x86_64-apple-darwin`, `aarch64-apple-darwin`
  * `x86_64-pc-windows-msvc`
  * `aarch64-linux-android` (for Termux)

### GUI release (desktop)

* Tauri packaging outputs standard installers:

  * `.msi` or `.exe` for Windows
  * `.dmg` for macOS
  * AppImage / deb / rpm options for Linux

### Web UI release

* Bundled inside the CLI (embedded assets) or inside the GUI (Tauri).
* No separate deployment required.

---

## Repo layout matching your folders

You already have:

* `cli/`
* `gui/`
* `web/`
  Add/keep:
* `core/` (Rust crate)

Suggested workspace:

* `core` = `reverse_ssh_core` (library crate)
* `cli` = `reverse_ssh_cli` (bin crate depends on core)
* `web` =

  * `server` (Rust axum bin depends on core)
  * `ui` (Svelte/React frontend)
* `gui` = Tauri app depends on core + reuses `web/ui` build output

---

## If you want an alternative stack

If you strongly prefer simpler build tooling over maximum safety/performance:

* **Go core** + `cobra` CLI + `wails` GUI + `chi` web server is also viable.
  But given your “very fast + adaptable + secure + cross-arch” requirements, **Rust core + Tauri + axum** is the cleanest fit.

---

If you tell me whether your “reverse SSH interface” is primarily:

1. `-R` reverse port forwarding to expose a local service remotely,
2. a reverse *shell* workflow, or
3. a multiplexed session manager (many tunnels/profiles),
   I can outline the **exact core module boundaries** (session supervisor, config schema, events API) and the minimal command surface for CLI/Web/GUI so you don’t paint yourself into a corner.
